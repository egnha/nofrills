% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deprecated.R
\name{deprecated}
\alias{deprecated}
\alias{as_fn}
\alias{make_fn_aware}
\alias{as_fn}
\alias{make_fn_aware}
\title{Deprecated functions}
\usage{
as_fn(.f)

make_fn_aware(f, ...)
}
\arguments{
\item{.f}{A function or an abbreviated anonymous-function expression of the
form \code{.(...)}, where \code{...} is a \link[=fn]{function declaration} (i.e., \code{.}
(dot) in this context is an alias of \code{\link[=fn]{fn()}}).
\link[rlang:quasiquotation]{Quasiquotation} is supported.}

\item{f}{Function, or symbol or name of a function.}

\item{...}{Name(s) of functional argument(s) of \code{f} (strings) or \code{NULL}.
Unsplicing of lists of strings is supported via \code{!!!}.}
}
\value{
\code{as_fn()}: If \code{.f} is a function, it is simply returned, otherwise
the function determined by the \link[=fn]{function declaration} is returned.

\code{make_fn_aware()}: A function with the same call signature as \code{f},
but whose function arguments, as designated by \code{...}, may be specified
using an abbreviated function expression of the form \code{.(...)}, cf.
\code{\link[=as_fn]{as_fn()}}. If \code{...} is empty or \code{NULL}, then \code{f} is simply returned.
}
\description{
These functions are softly deprecated and may be removed from a future
version of \pkg{nofrills}. They were intended to enable a shorter
\code{fn()}-syntax for higher-order functionsâ€”a negligible convenience. Instead,
simply invoke \code{fn()} directly.
}
\details{
\code{as_fn()} is for functions that take functional arguments. Use
\code{as_fn()} \emph{inside} a function to enable it to comprehend a minimal
anonymous-function notation for arguments that are functions. This notation
is that of \code{\link[=fn]{fn()}}, but with \sQuote{\code{fn}} replaced by \sQuote{\code{.}} (dot).
\code{as_fn()} cannot follow promise expressions across function calls. It is
only intended to work in the immediate context in which a function
declaration is to be interpreted (see \emph{Examples}).

\code{make_fn_aware()} is a functional operator that enhances a function
by enabling it to interpret abbreviated functional arguments.
}
\examples{
\dontrun{
call_fn <- function(.f, x) {
  f <- as_fn(.f)
  f(x)
}
call_fn(log, 1)
call_fn(.(. ~ sin(.) ^ 2), 1)
# simplified function expressions support quasiquotation
f <- sin
call_fn(.(. ~ (!!f)(.) ^ 2), 1)

## wrap Map() to accept abbreviated anonymous function expressions
Map_ <- function (f, ...) {
  f <- as_fn(f)
  mapply(FUN = f, ..., SIMPLIFY = FALSE)
}
# you can call Map_() just like Map()
Map_(function(x, y, z) paste(x, y, paste("and", z), sep = ", "), 1:3, 4:6, 7:9)
# or use a simplified function expression
Map_(.(x, y, z ~ paste(x, y, paste("and", z), sep = ", ")), 1:3, 4:6, 7:9)

## abbreviated anonymous functions are interpreted in the calling environment
# so this works, as expected
foo <- function(a) as_fn(a)
foo(.(x ~ x + 1))
# but as_fn() can't interpret abbreviated anonymous functions across calls
foo <- function(a) bar(a)
bar <- function(b) as_fn(b)
foo(.(x ~ x + 1))
}

\dontrun{
reduce <- make_fn_aware(Reduce, "f")

## reduce() behaves just like Reduce()
Reduce(function(u, v) u + 1 / v, c(3, 7, 15, 1, 292), right = TRUE)
reduce(function(u, v) u + 1 / v, c(3, 7, 15, 1, 292), right = TRUE)

## reduce() can also interpret abbreviated function expressions
reduce(.(u, v ~ u + 1 / v), c(3, 7, 15, 1, 292), right = TRUE)
}

}
\keyword{internal}
