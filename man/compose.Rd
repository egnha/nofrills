% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compose.R
\name{compose}
\alias{compose}
\alias{\%<<<\%}
\alias{\%>>>\%}
\alias{decompose}
\title{Compose functions}
\usage{
compose(...)

f \%<<<\% g

g \%>>>\% f

decompose(f)
}
\arguments{
\item{...}{Functions or lists thereof to compose. Lists of functions are
automatically spliced in. (Explicit \link[rlang:quasiquotation]{splicing} via
\code{!!!} is also supported.) Following convention, functions are composed from
right to left.}

\item{f, g}{Functions.}
}
\value{
\code{compose()}, \code{\%<<<\%} and \code{\%>>>\%} return a function
composition, whose \link[=formals]{formals} match those of the initial function
called (as a closure).

\code{decompose()} returns the list of composite functions of a function
composition (in reverse calling order), and wraps a non-composite function
in a list.
}
\description{
Compose functions in three ways:
\itemize{
\item Using \code{compose()}: \code{compose(f, g)} is the function that calls \code{g} followed
by \code{f}. It has the \link[=formals]{formals} of \code{g}.
\item Using \code{\%<<<\%} (\dQuote{backward} composition): \code{f \%<<<\% g}
is another way to express \code{compose(f, g)}.
\item Using \code{\%>>>\%} (\dQuote{forward} composition): \code{f \%>>>\% g}
is another way to express \code{compose(g, f)}.
}

Use \code{decompose()} to recover the list of composite functions of a function
composition.
}
\section{Properties}{
 \code{compose()} is \emph{associative}, semantically and
operationally. This means, for instance, that
\code{compose(f, g, h)},
\code{compose(f, compose(g, h))},
\code{compose(compose(f, g), h)},
are implemented as the \emph{same function}. In other words, lists of functions
are automatically \dQuote{flattened out} when they are composed, so nested
compositions do not pile up.

\code{decompose()} and \code{compose()} are \emph{mutually invertible}.
\code{compose(decompose(f))} is the same as \code{f}, when \code{f} is a function.
\code{decompose(compose(fs))} is the same as \code{fs}, when \code{fs} is a list of
functions.
}

\examples{
# Functions are composed from right to left (following convention)
inv <- curry(`/`)(1)  # reciprocal
f <- compose(inv, log, abs)
stopifnot(isTRUE(all.equal(f(-2), 1 / log(abs(-2)))))

# "Backward" composition operator composes from right to left, like compose()
f1 <- inv \%<<<\% log \%<<<\% abs
stopifnot(isTRUE(all.equal(f1(-2), f(-2))))

# Forward composition operator composes from left to right
f2 <- abs \%>>>\% log \%>>>\% inv
stopifnot(isTRUE(all.equal(f2(-2), f(-2))))

# Curry composition to create input/output transformers
transform_in  <- curry(`\%>>>\%`)
transform_out <- curry(`\%<<<\%`)

# Presume to_json()/from_json() convert to/from JSON
json_out <- transform_out(to_json)   # transforms function to produce JSON
json_in  <- transform_in(from_json)  # transforms function to consume JSON
jsonify  <- json_in \%>>>\% json_out   # transforms function to JSON function

# Argument signature of inner most function is preserved
g <- function(a, b = 0) a + b
stopifnot(identical(formals(compose(inv, g)), formals(g)))

# Compositions can be provided by lists, in several equivalent ways
f3 <- compose(list(inv, log, abs))
f4 <- compose(!!! list(inv, log, abs))
f5 <- compose(inv, list(log, abs))
f6 <- compose(inv, !!! list(log, abs))
stopifnot(
  isTRUE(all.equal(f3, f)), isTRUE(all.equal(f3(-2), f(-2))),
  isTRUE(all.equal(f4, f)), isTRUE(all.equal(f4(-2), f(-2))),
  isTRUE(all.equal(f5, f)), isTRUE(all.equal(f5(-2), f(-2))),
  isTRUE(all.equal(f6, f)), isTRUE(all.equal(f6(-2), f(-2)))
)

# compose() and decompose() are mutally invertible
f7 <- compose(inv, decompose(compose(log, abs)))
stopifnot(isTRUE(all.equal(f7, f)), isTRUE(all.equal(f7(-2), f(-2))))
fs <- list(inv, log, abs)
stopifnot(isTRUE(all.equal(decompose(compose(fs)), fs)))

}
